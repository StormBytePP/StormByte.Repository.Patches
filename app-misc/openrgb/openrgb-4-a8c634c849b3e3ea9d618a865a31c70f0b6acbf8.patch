From a8c634c849b3e3ea9d618a865a31c70f0b6acbf8 Mon Sep 17 00:00:00 2001
From: Geoffrey Mon <geofbot@gmail.com>
Date: Wed, 24 May 2023 18:27:46 -0500
Subject: [PATCH] basic Fury DDR5 support with Static + Rainbow modes

---
 .../KingstonFuryDRAMController.cpp            | 305 ++++--------
 .../KingstonFuryDRAMController.h              |  64 ++-
 .../KingstonFuryDRAMControllerDetect.cpp      |  56 +--
 .../RGBController_KingstonFuryDRAM.cpp        | 453 +++++++-----------
 4 files changed, 337 insertions(+), 541 deletions(-)

diff --git a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.cpp b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.cpp
index 4beae2192..0d42cee87 100644
--- a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.cpp
+++ b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.cpp
@@ -1,31 +1,13 @@
-/*-----------------------------------------*\
-|  HyperXDRAMController.cpp                 |
-|                                           |
-|  Definitions and types for HyperX Predator|
-|  and Fury RGB RAM lighting controller     |
-|                                           |
-|  Adam Honse (CalcProgrammer1) 6/29/2019   |
-\*-----------------------------------------*/
-
 #include "KingstonFuryDRAMController.h"
 #include <cstring>
+#include <vector>
 #include "LogManager.h"
-KingstonFuryDRAMController::KingstonFuryDRAMController(i2c_smbus_interface* bus, hyperx_dev_id dev, unsigned char slots)
+
+KingstonFuryDRAMController::KingstonFuryDRAMController(
+    i2c_smbus_interface* bus, std::vector<int> slots)
 {
     this->bus   = bus;
-    this->dev   = dev;
-    slots_valid = slots;
-
-    led_count = 5;
-
-  /*  for(unsigned int slot = 0; slot < 4; slot++)
-    {
-        if(((slots_valid & ( 0x01 << slot)) != 0)
-         ||((slots_valid & ( 0x10 << slot)) != 0))
-        {
-            led_count += 5;
-        }
-    }*/
+    this->slots = slots;
 
     mode = 0;
 }
@@ -38,231 +20,140 @@ KingstonFuryDRAMController::~KingstonFuryDRAMController()
 std::string KingstonFuryDRAMController::GetDeviceLocation()
 {
     std::string return_string(bus->device_name);
-    char addr[5];
-    snprintf(addr, 5, "0x%02X", dev);
-    return_string.append(", address ");
-    return_string.append(addr);
+    return_string.append(", addresses ");
+    for (int idx = 0; idx < slots.size(); idx++)
+    {
+        char addr[6];
+        snprintf(addr, 6, "0x%02X ", 0x60 + slots[idx]);
+        return_string.append(addr);
+    }
     return("I2C: " + return_string);
 }
 
 unsigned KingstonFuryDRAMController::GetLEDCount()
 {
-    return(5);
+    return FURY_LEDS_PER_DIMM * slots.size();
 }
 
 unsigned int KingstonFuryDRAMController::GetSlotCount()
 {
-  unsigned int slot_count = 0;
-
-    for(int slot = 0; slot < 4; slot++)
-    {
-        if(((slots_valid & ( 0x01 << slot)) != 0)
-         ||((slots_valid & ( 0x10 << slot)) != 0))
-        {
-            slot_count++;
-        }
-    }
-
-    return(slot_count);
+    return slots.size();
 }
 
 unsigned int KingstonFuryDRAMController::GetMode()
 {
-    return(FURY_MODE_STATIC);
+    return mode;
 }
 
-void KingstonFuryDRAMController::SendApply()
+void KingstonFuryDRAMController::SendPreamble()
 {
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_END_TRNSFER);
-}
+    SendBegin();
 
-void KingstonFuryDRAMController::SetEffectColor(unsigned char red, unsigned char green, unsigned char blue)
-{
-    LOG_DEBUG("[fury] Set color 1");
-bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_BEGIN_TRNSFER);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_R, red  );
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_G, green);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_B, blue );
+    // TODO rain/firework modes set all indices to 0
+    for (int idx = 0; idx < slots.size(); idx++)
+    {
+        // Stick with index 0 takes command over all other sticks
+        // (presumably using the advertised infrared syncing).
+        // The official software writes the indices in decreasing order.
+        char written_index = slots.size() - (idx + 1);
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 FURY_REG_INDEX,
+                                                 written_index);
+        LOG_DEBUG("[%s] %02X writing index %d; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx],
+                  written_index, res);
+    }
+    // The RGB controller is a bit slow and requires delay;
+    // however, we can delay once for all of the sticks instead of
+    // delaying individually for each stick.
+    std::this_thread::sleep_for(FURY_DELAY);
 
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_END_TRNSFER);
+    SendApply();
 }
 
-void KingstonFuryDRAMController::SetAllColors(unsigned char red, unsigned char green, unsigned char blue)
+void KingstonFuryDRAMController::SendBegin()
 {
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_BEGIN_TRNSFER);
-    LOG_DEBUG("[fury] Set color");
-    /*-----------------------------------------------------*\
-    | Loop through all slots and only set those which are   |
-    | active.                                               |
-    \*-----------------------------------------------------*/
-    for(unsigned int slot_idx = 0; slot_idx < 4; slot_idx++)
+    for (int idx = 0; idx < slots.size(); idx++)
     {
-        unsigned char slot = slot_map[slot_idx];
-
-        if(((slots_valid & ( 0x01 << slot)) != 0)
-         ||((slots_valid & ( 0x10 << slot)) != 0))
-        {
-
-            if(mode == FURY_MODE_STATIC)
-            {
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_MODE, FURY_MODE_STATIC);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_R, red  );
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_G, green);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_B, blue );
-            }
-        }
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 FURY_REG_APPLY,
+                                                 FURY_BEGIN_TRNSFER);
+        LOG_DEBUG("[%s] %02X beginning transaction; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx], res);
     }
-
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_END_TRNSFER);
+    std::this_thread::sleep_for(FURY_DELAY);
 }
 
-void KingstonFuryDRAMController::SetLEDColor(unsigned int led, unsigned char red, unsigned char green, unsigned char blue)
+void KingstonFuryDRAMController::SendApply()
 {
-       bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_BEGIN_TRNSFER);
-LOG_DEBUG("[fury] Set color");
-    /*-----------------------------------------------------*\
-    | Loop through all slots and only set those which are   |
-    | active.                                               |
-    \*-----------------------------------------------------*/
-    for(unsigned int slot_idx = 0; slot_idx < 4; slot_idx++)
+    for (int idx = 0; idx < slots.size(); idx++)
     {
-        unsigned char slot = slot_map[slot_idx];
-
-        if(((slots_valid & ( 0x01 << slot)) != 0)
-         ||((slots_valid & ( 0x10 << slot)) != 0))
-        {
-
-            if(mode == FURY_MODE_STATIC)
-            {
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_MODE, FURY_MODE_STATIC);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_R, red  );
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_G, green);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_B, blue );
-            }
-        }
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 FURY_REG_APPLY,
+                                                 FURY_END_TRNSFER);
+        LOG_DEBUG("[%s] %02X ending transaction; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx], res);
     }
-
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_END_TRNSFER);
+    std::this_thread::sleep_for(FURY_DELAY);
 }
 
-
-void KingstonFuryDRAMController::SetLEDColor(unsigned int slot, unsigned int led, unsigned char red, unsigned char green, unsigned char blue)
+void KingstonFuryDRAMController::SetModeCode(unsigned char val)
 {
-      bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_BEGIN_TRNSFER);
-LOG_DEBUG("[fury] Set color");
-    /*-----------------------------------------------------*\
-    | Loop through all slots and only set those which are   |
-    | active.                                               |
-    \*-----------------------------------------------------*/
-    for(unsigned int slot_idx = 0; slot_idx < 4; slot_idx++)
+    mode = val;
+    for (int idx = 0; idx < slots.size(); idx++)
     {
-        unsigned char slot = slot_map[slot_idx];
-
-        if(((slots_valid & ( 0x01 << slot)) != 0)
-         ||((slots_valid & ( 0x10 << slot)) != 0))
-        {
-
-            if(mode == FURY_MODE_STATIC)
-            {
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_MODE, FURY_MODE_STATIC);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_R, red  );
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_G, green);
-                bus->i2c_smbus_write_byte_data(dev, FURY_REG_COLOR_B, blue );
-            }
-        }
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 FURY_REG_MODE,
+                                                 val);
+        LOG_DEBUG("[%s] %02X setting mode %d; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx], val, res);
     }
-
-    bus->i2c_smbus_write_byte_data(dev, FURY_REG_APPLY, FURY_END_TRNSFER);
+    std::this_thread::sleep_for(FURY_DELAY);
 }
 
-void KingstonFuryDRAMController::SetMode(unsigned char new_mode, bool random, unsigned short new_speed)
+void KingstonFuryDRAMController::SetNumSlots()
 {
-    mode  = new_mode;
-    speed = new_speed;
-LOG_DEBUG("[fury] Set mode");
-   // bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_APPLY, 0x01);
-
-    /*-----------------------------------------------------*\
-    | Determine which mode register to use.                 |
-    | If set to random color mode, use Mode1.               |
-    | If set to fixed color mode, use Mode2.                |
-    \*-----------------------------------------------------*/
-    unsigned char mode_reg;
-
-   /* if(random)
-    {
-        mode_reg = HYPERX_REG_MODE_RANDOM;
-    }
-    else
+    for (int idx = 0; idx < slots.size(); idx++)
     {
-        mode_reg = HYPERX_REG_MODE_CUSTOM;
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 FURY_REG_NUM_SLOTS,
+                                                 slots.size());
+        LOG_DEBUG("[%s] %02X sending number of DIMMs %d; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx], slots.size(), res);
     }
+    std::this_thread::sleep_for(FURY_DELAY);
+}
 
-    switch (mode)
+void KingstonFuryDRAMController::SetRegister(int reg, unsigned char val)
+{
+    for (int idx = 0; idx < slots.size(); idx++)
     {
-    case HYPERX_MODE_DIRECT:
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_MODE_INDEPENDENT, HYPERX_MODE3_DIRECT);
-        break;
-
-    case FURY_MODE_STATIC:
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_MODE_CUSTOM, HYPERX_MODE2_STATIC);
-        break;
-
-    case HYPERX_MODE_RAINBOW:
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_MODE_RANDOM, HYPERX_MODE1_RAINBOW);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_LSB, speed & 0xFF);
-        break;
-
-    case HYPERX_MODE_COMET:
-        bus->i2c_smbus_write_byte_data(dev, mode_reg, HYPERX_MODE2_COMET);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_LSB, speed & 0xFF);
-        break;
-
-    case HYPERX_MODE_HEARTBEAT:
-        bus->i2c_smbus_write_byte_data(dev, mode_reg, HYPERX_MODE2_HEARTBEAT);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_DELAY_TIME_MSB, 0x03);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_DELAY_TIME_LSB, 0xE8);
-        break;
-
-    case HYPERX_MODE_CYCLE:
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_MODE_RANDOM, HYPERX_MODE1_CYCLE);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_CHANGE_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_CHANGE_TIME_LSB, speed & 0xFF);
-        break;
-
-    case HYPERX_MODE_BREATHING:
-        bus->i2c_smbus_write_byte_data(dev, mode_reg, HYPERX_MODE2_BREATHING);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_FADE_IN_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_FADE_IN_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_FADE_OUT_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_FADE_OUT_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_MSB, 0x00);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_LSB, 0x00);
-        break;
+        int res = bus->i2c_smbus_write_byte_data(0x60 + slots[idx],
+                                                 reg,
+                                                 val);
+        LOG_DEBUG("[%s] %02X setting register &%02X=%02X; res=%02X",
+                  FURY_CONTROLLER_NAME, 0x60 + slots[idx], reg, val, res);
+    }
+    std::this_thread::sleep_for(FURY_DELAY);
+}
 
-    case HYPERX_MODE_BOUNCE:
-        bus->i2c_smbus_write_byte_data(dev, mode_reg, HYPERX_MODE2_BOUNCE);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_TIMER_LSB, speed & 0xFF);
-        break;
 
-    case HYPERX_MODE_BLINK:
-        bus->i2c_smbus_write_byte_data(dev, mode_reg, HYPERX_MODE2_BLINK);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_MSB, speed >> 8);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_OFF_TIME_LSB, speed & 0xFF);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_MSB, 0x07);
-        bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_ON_TIME_LSB, 0xD4);
-        break;
+void KingstonFuryDRAMController::SetLEDColor(unsigned int slot, unsigned int led, unsigned char red, unsigned char green, unsigned char blue)
+{
+    // TODO set each slot at the "same time" to reduce delays
+    if (slot < 0 || slot >= slots.size()) {
+        return;
     }
-
-    bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_APPLY, 0x02);
-    bus->i2c_smbus_write_byte_data(dev, HYPERX_REG_APPLY, 0x03);*/
+    if (led < 0 || led >= FURY_LEDS_PER_DIMM) {
+        return;
+    }
+    int red_register = FURY_REG_BASE_RED + 3 * led;
+    int green_register = FURY_REG_BASE_GREEN + 3 * led;
+    int blue_register = FURY_REG_BASE_BLUE + 3 * led;
+    bus->i2c_smbus_write_byte_data(0x60 + slots[slot], red_register, red  );
+    std::this_thread::sleep_for(FURY_DELAY);
+    bus->i2c_smbus_write_byte_data(0x60 + slots[slot], green_register, green);
+    std::this_thread::sleep_for(FURY_DELAY);
+    bus->i2c_smbus_write_byte_data(0x60 + slots[slot], blue_register, blue );
+    std::this_thread::sleep_for(FURY_DELAY);
 }
diff --git a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.h b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.h
index 8d84e5354..81d505e27 100644
--- a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.h
+++ b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMController.h
@@ -8,45 +8,63 @@
 \*-----------------------------------------*/
 
 #include <string>
+#include <vector>
 #include "i2c_smbus.h"
 
 #pragma once
 
+#define FURY_CONTROLLER_NAME "Kingston Fury DDR5 DRAM"
+// TODO consider reducing this delay and adding capability of repeating register writes on failure
+#define FURY_DELAY std::chrono::milliseconds(30)
+#define FURY_MAX_SLOTS 4
+#define FURY_LEDS_PER_DIMM 12
+
 typedef unsigned char	hyperx_dev_id;
 typedef unsigned short	hyperx_register;
 
 enum
 {
-    FURY_REG_APPLY                    = 0x08,     /* Apply changes register               */
-    FURY_REG_COLOR_R                  = 0x31,     /* Apply changes register               */
-    FURY_REG_COLOR_G                  = 0x32,     /* Apply changes register               */
-    FURY_REG_COLOR_B                  = 0x33,     /* Apply changes register               */
+    FURY_MODEL_FURY                   = 0x10,
+    FURY_MODEL_RENEGADE               = 0x11,
+};
+
+enum
+{
+    FURY_REG_APPLY                    = 0x08,
     FURY_REG_MODE                     = 0x09,
+    FURY_REG_INDEX                    = 0x0B,
+    FURY_REG_DIRECTION                = 0x0C,
+    FURY_REG_DELAY                    = 0x0D,
+    FURY_REG_SPEED                    = 0x0E,
+    FURY_REG_BRIGHTNESS               = 0x20,
+    FURY_REG_NUM_SLOTS                = 0x27,
+    FURY_REG_BASE_RED                 = 0x50,
+    FURY_REG_BASE_GREEN               = 0x51,
+    FURY_REG_BASE_BLUE                = 0x52,
 };
 
 enum
 {
-    FURY_BEGIN_TRNSFER                = 0x53,     /* Begin writing data to register       */
-    FURY_END_TRNSFER                  = 0x44,     /* Begin writing data to register       */
+    FURY_BEGIN_TRNSFER                = 0x53,
+    FURY_END_TRNSFER                  = 0x44,
 };
 
 enum
 {
-    FURY_MODE_STATIC                  = 0x00,     /* Begin writing data to register       */
+    FURY_MODE_STATIC                  = 0x10, // static mode with individual colors
+    FURY_MODE_RAINBOW                 = 0x01,
 };
 
-static const unsigned char slot_map[4] =
+enum
 {
-    0,
-    2,
-    1,
-    3
+    FURY_DIR_BOTTOM_TO_TOP            = 0x01,
+    FURY_DIR_TOP_TO_BOTTOM            = 0x02,
 };
 
 class KingstonFuryDRAMController
 {
 public:
-    KingstonFuryDRAMController(i2c_smbus_interface* bus, hyperx_dev_id dev, unsigned char slots);
+    KingstonFuryDRAMController(i2c_smbus_interface* bus, std::vector<int> slots);
     ~KingstonFuryDRAMController();
 
     std::string     GetDeviceLocation();
@@ -54,20 +72,18 @@ public:
     unsigned int    GetSlotCount();
     unsigned int    GetMode();
 
+    void            SendPreamble();
+    void            SendBegin();
     void            SendApply();
+    void            SetModeCode(unsigned char val);
+    void            SetNumSlots();
 
-    void            SetMode(unsigned char new_mode, bool random, unsigned short new_speed);
-
-    void            SetAllColors(unsigned char red, unsigned char green, unsigned char blue);
-    void            SetEffectColor(unsigned char red, unsigned char green, unsigned char blue);
-    void            SetLEDColor(unsigned int led, unsigned char red, unsigned char green, unsigned char blue);
-    void            SetLEDColor(unsigned int slot, unsigned int led, unsigned char red, unsigned char green, unsigned char blue);
+    void            SetRegister(int reg, unsigned char val);
+    void            SetLEDColor(unsigned int slot_idx, unsigned int led_idx,
+                                unsigned char red, unsigned char green, unsigned char blue);
 
 private:
-    unsigned int            led_count;
-    unsigned char           slots_valid;
     i2c_smbus_interface*    bus;
-    hyperx_dev_id           dev;
-    unsigned int            mode;
-    unsigned short          speed;
+    std::vector<int>        slots;
+    unsigned char           mode;
 };
diff --git a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMControllerDetect.cpp b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMControllerDetect.cpp
index e41c8e19f..d44e33705 100644
--- a/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMControllerDetect.cpp
+++ b/Controllers/KingstonFuryDRAMController/KingstonFuryDRAMControllerDetect.cpp
@@ -6,18 +6,16 @@
 #include "i2c_smbus.h"
 #include "pci_ids.h"
 #include <vector>
+#include <bitset>
 #include <stdio.h>
 #include <stdlib.h>
 
 using namespace std::chrono_literals;
 
-#define FURY_CONTROLLER_NAME "Kingston Fury DDR5 DRAM"
-#define FURY_DELAY 30ms
-
 // TODO is this safe for non-Kingston devices?
 bool TestForFuryDDR5(i2c_smbus_interface* bus, int slot_index)
 {
-    // TODO make these constants
+    // TODO make these constants?
     int base_4x_addr = 0x48;
     int base_5x_addr = 0x50;
     int base_6x_addr = 0x60;
@@ -25,8 +23,8 @@ bool TestForFuryDDR5(i2c_smbus_interface* bus, int slot_index)
     int addr;
     int res;
 
-    if (slot_index < 0 || slot_index >= 8) {
-        LOG_DEBUG("[%s] Fury DDR5 detect called for invalid slot %d",
+    if (slot_index < 0 || slot_index >= FURY_MAX_SLOTS) {
+        LOG_DEBUG("[%s] Fury DDR5 detect called on invalid slot index %d",
                   FURY_CONTROLLER_NAME, slot_index);
         return false;
     }
@@ -76,9 +74,8 @@ bool TestForFuryDDR5(i2c_smbus_interface* bus, int slot_index)
         return false;
     }
 
-    // TODO make these constants
-    if (model_code != 0x10     // Fury Beast
-        && model_code != 0x11) // Fury Renegade
+    if (model_code != FURY_MODEL_FURY
+        && model_code != FURY_MODEL_RENEGADE)
     {
         LOG_DEBUG("[%s] Unknown model code", FURY_CONTROLLER_NAME);
         return false;
@@ -88,7 +85,6 @@ bool TestForFuryDDR5(i2c_smbus_interface* bus, int slot_index)
 }
 
 
-
 /******************************************************************************************\
 *                                                                                          *
 *   DetectKingstonFuryDRAMControllers                                                      *
@@ -107,7 +103,8 @@ void DetectKingstonFuryDRAMControllers(std::vector<i2c_smbus_interface*> &busses
 
         IF_DRAM_SMBUS(busses[bus]->pci_vendor, busses[bus]->pci_device)
         {
-            for (int slot_index = 0; slot_index < 8; slot_index++)
+            std::vector<int> slots;
+            for (int slot_index = 0; slot_index < FURY_MAX_SLOTS; slot_index++)
             {
                 int retries = 0;
                 bool success = false;
@@ -121,36 +118,19 @@ void DetectKingstonFuryDRAMControllers(std::vector<i2c_smbus_interface*> &busses
                 if (success) {
                     LOG_DEBUG("[%s] detected at slot index %d",
                               FURY_CONTROLLER_NAME, slot_index);
-                    KingstonFuryDRAMController*     controller     = new KingstonFuryDRAMController(busses[bus], 0x60+slot_index, slot_index);
-                    RGBController_KingstonFuryDRAM* rgb_controller = new RGBController_KingstonFuryDRAM(controller);
-                    rgb_controller->name = "Kingston Fury DDR5 RGB";
+                    slots.push_back(slot_index);
 
-                    ResourceManager::get()->RegisterRGBController(rgb_controller);
                 }
             }
-                // for(int slot_addr = 0x48; slot_addr <= 0x4b; slot_addr++)
-                // {
-
-                //     int read_0x21 = busses[bus]->i2c_smbus_read_byte_data(slot_addr, 0x21);
-                //     int read_0x25 = busses[bus]->i2c_smbus_read_byte_data(slot_addr, 0x25);
-                //     int read_0x27 = busses[bus]->i2c_smbus_read_byte_data(slot_addr, 0x27);
-
-                //     if((read_0x21 == 0x78) && (read_0x25 == 0x78) && (read_0x27 == 0x78))
-                //     {
-                //         LOG_DEBUG("[%s] SPD check success: addr of control reg: %d", FURY_CONTROLLER_NAME, 0x60+(slot_addr-0x48));
-                //         KingstonFuryDRAMController*     controller     = new KingstonFuryDRAMController(busses[bus], 0x60+(slot_addr-0x48), slot_addr-0x48);
-                //         RGBController_KingstonFuryDRAM* rgb_controller = new RGBController_KingstonFuryDRAM(controller);
-                //         rgb_controller->name = "Kingston Fury DDR5 RGB";
-
-                //         ResourceManager::get()->RegisterRGBController(rgb_controller);
-                //     }
-                //     else
-                //     {
-                //         LOG_DEBUG("[%s] SPD check failed", FURY_CONTROLLER_NAME);
-                //     }
-
-                //     std::this_thread::sleep_for(1ms);
-                // }
+
+            if (!slots.empty()) {
+                KingstonFuryDRAMController* controller =
+                    new KingstonFuryDRAMController(busses[bus], slots);
+                RGBController_KingstonFuryDRAM* rgb_controller =
+                    new RGBController_KingstonFuryDRAM(controller);
+                rgb_controller->name = "Kingston Fury DDR5 RGB";
+                ResourceManager::get()->RegisterRGBController(rgb_controller);
+            }
         }
     }
 
diff --git a/Controllers/KingstonFuryDRAMController/RGBController_KingstonFuryDRAM.cpp b/Controllers/KingstonFuryDRAMController/RGBController_KingstonFuryDRAM.cpp
index 9696a99f5..9f044ebbb 100644
--- a/Controllers/KingstonFuryDRAMController/RGBController_KingstonFuryDRAM.cpp
+++ b/Controllers/KingstonFuryDRAMController/RGBController_KingstonFuryDRAM.cpp
@@ -1,272 +1,181 @@
-/*-----------------------------------------*\
-|  RGBController_KingstonFuryDRAM.cpp       |
-|                                           |
-|  Generic RGB Interface for OpenAuraSDK    |
-|                      Fury RGB interface   |
-|                                           |
-|  Luka Panio (luka177) 11/12/2022          |
-\*-----------------------------------------*/
-
-#include "RGBController_KingstonFuryDRAM.h"
-#include "KingstonFuryDRAMController.h"
-
-/**------------------------------------------------------------------*\
-    @name Fury DRAM
-    @category RAM
-    @type I2C
-    @save :x:
-    @direct :white_check_mark:
-    @effects :white_check_mark:
-    @detectors DetectHyperXDRAMControllers
-    @comment
-\*-------------------------------------------------------------------*/
-
-RGBController_KingstonFuryDRAM::RGBController_KingstonFuryDRAM(KingstonFuryDRAMController* controller_ptr)
-{
-    controller  = controller_ptr;
-
-    name        = "Fury DRAM";
-    vendor      = "Kingston";
-    type        = DEVICE_TYPE_DRAM;
-    description = "Kingston Fury Beast DRAM Device";
-    location    = controller->GetDeviceLocation();
-
-   /* mode Direct;
-    Direct.name       = "Direct";
-    Direct.value      = HYPERX_MODE_DIRECT;
-    Direct.flags      = MODE_FLAG_HAS_PER_LED_COLOR;
-    Direct.color_mode = MODE_COLORS_PER_LED;
-    modes.push_back(Direct);*/
-
-    mode Static;
-    Static.name       = "Static";
-    Static.value      = FURY_MODE_STATIC;
-    Static.flags      = MODE_FLAG_HAS_MODE_SPECIFIC_COLOR;
-    Static.colors_min = 1;
-    Static.colors_max = 1;
-    Static.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Static.colors.resize(1);
-    modes.push_back(Static);
-
-    /*mode Rainbow;
-    Rainbow.name       = "Rainbow";
-    Rainbow.value      = HYPERX_MODE_RAINBOW;
-    Rainbow.flags      = MODE_FLAG_HAS_SPEED;
-    Rainbow.speed_min  = HYPERX_SPEED_RAINBOW_SLOW;
-    Rainbow.speed_max  = HYPERX_SPEED_RAINBOW_FAST;
-    Rainbow.speed      = HYPERX_SPEED_RAINBOW_NORMAL;
-    Rainbow.color_mode = MODE_COLORS_NONE;
-    modes.push_back(Rainbow);
-
-    mode Comet;
-    Comet.name       = "Comet";
-    Comet.value      = HYPERX_MODE_COMET;
-    Comet.flags      = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR | MODE_FLAG_HAS_RANDOM_COLOR;
-    Comet.speed_min  = HYPERX_SPEED_COMET_SLOW;
-    Comet.speed_max  = HYPERX_SPEED_COMET_FAST;
-    Comet.colors_min = 1;
-    Comet.colors_max = 1;
-    Comet.speed      = HYPERX_SPEED_COMET_NORMAL;
-    Comet.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Comet.colors.resize(1);
-    modes.push_back(Comet);
-
-    mode Heartbeat;
-    Heartbeat.name       = "Heartbeat";
-    Heartbeat.value      = HYPERX_MODE_HEARTBEAT;
-    Heartbeat.flags      = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR | MODE_FLAG_HAS_RANDOM_COLOR;
-    Heartbeat.speed_min  = HYPERX_SPEED_COMET_SLOW;
-    Heartbeat.speed_max  = HYPERX_SPEED_COMET_FAST;
-    Heartbeat.colors_min = 1;
-    Heartbeat.colors_max = 1;
-    Heartbeat.speed      = HYPERX_SPEED_COMET_NORMAL;
-    Heartbeat.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Heartbeat.colors.resize(1);
-    modes.push_back(Heartbeat);
-
-    mode SpectrumCycle;
-    SpectrumCycle.name       = "Spectrum Cycle";
-    SpectrumCycle.value      = HYPERX_MODE_CYCLE;
-    SpectrumCycle.flags      = MODE_FLAG_HAS_SPEED;
-    SpectrumCycle.speed_min  = HYPERX_SPEED_CYCLE_SLOW;
-    SpectrumCycle.speed_max  = HYPERX_SPEED_CYCLE_FAST;
-    SpectrumCycle.speed      = HYPERX_SPEED_CYCLE_NORMAL;
-    SpectrumCycle.color_mode = MODE_COLORS_NONE;
-    modes.push_back(SpectrumCycle);
-
-    mode Breathing;
-    Breathing.name       = "Breathing";
-    Breathing.value      = HYPERX_MODE_BREATHING;
-    Breathing.flags      = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR | MODE_FLAG_HAS_RANDOM_COLOR;
-    Breathing.speed_min  = HYPERX_SPEED_BREATHING_SLOW;
-    Breathing.speed_max  = HYPERX_SPEED_BREATHING_FAST;
-    Breathing.colors_min = 1;
-    Breathing.colors_max = 1;
-    Breathing.speed      = HYPERX_SPEED_BREATHING_NORMAL;
-    Breathing.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Breathing.colors.resize(1);
-    modes.push_back(Breathing);
-
-    mode Bounce;
-    Bounce.name       = "Bounce";
-    Bounce.value      = HYPERX_MODE_BOUNCE;
-    Bounce.flags      = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR | MODE_FLAG_HAS_RANDOM_COLOR;
-    Bounce.speed_min  = HYPERX_SPEED_BOUNCE_SLOW;
-    Bounce.speed_max  = HYPERX_SPEED_BOUNCE_FAST;
-    Bounce.colors_min = 1;
-    Bounce.colors_max = 1;
-    Bounce.speed      = HYPERX_SPEED_BOUNCE_NORMAL;
-    Bounce.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Bounce.colors.resize(1);
-    modes.push_back(Bounce);
-
-    mode Blink;
-    Blink.name       = "Blink";
-    Blink.value      = HYPERX_MODE_BLINK;
-    Blink.flags      = MODE_FLAG_HAS_SPEED | MODE_FLAG_HAS_MODE_SPECIFIC_COLOR | MODE_FLAG_HAS_RANDOM_COLOR;
-    Blink.speed_min  = HYPERX_SPEED_BLINK_SLOW;
-    Blink.speed_max  = HYPERX_SPEED_BLINK_FAST;
-    Blink.colors_min = 1;
-    Blink.colors_max = 1;
-    Blink.speed      = HYPERX_SPEED_BLINK_NORMAL;
-    Blink.color_mode = MODE_COLORS_MODE_SPECIFIC;
-    Blink.colors.resize(1);
-    modes.push_back(Blink);*/
-
-    SetupZones();
-}
-
-RGBController_KingstonFuryDRAM::~RGBController_KingstonFuryDRAM()
-{
-    delete controller;
-}
-
-void RGBController_KingstonFuryDRAM::SetupZones()
-{
-    for(unsigned int slot = 0; slot < controller->GetSlotCount(); slot++)
-    {
-        zone* new_zone          = new zone;
-
-        new_zone->name          = "Fury Slot ";
-        new_zone->name.append(std::to_string(slot + 1));
-        new_zone->type          = ZONE_TYPE_LINEAR;
-        new_zone->leds_min      = 5;
-        new_zone->leds_max      = 5;
-        new_zone->leds_count    = 5;
-        new_zone->matrix_map    = NULL;
-
-        zones.push_back(*new_zone);
-    }
-
-    for(std::size_t zone_idx = 0; zone_idx < zones.size(); zone_idx++)
-    {
-        for(std::size_t led_idx = 0; led_idx < zones[zone_idx].leds_count; led_idx++)
-        {
-            led* new_led        = new led();
-
-            new_led->name       = "Fury Slot ";
-            new_led->name.append(std::to_string(zone_idx + 1));
-            new_led->name.append(", LED ");
-            new_led->name.append(std::to_string(led_idx + 1));
-
-            new_led->value      = leds.size();
-
-            leds.push_back(*new_led);
-        }
-    }
-
-    SetupColors();
-}
-
-void RGBController_KingstonFuryDRAM::ResizeZone(int /*zone*/, int /*new_size*/)
-{
-    /*---------------------------------------------------------*\
-    | This device does not support resizing zones               |
-    \*---------------------------------------------------------*/
-}
-
-void RGBController_KingstonFuryDRAM::DeviceUpdateLEDs()
-{
-    if(controller->GetMode() == FURY_MODE_STATIC)
-    {
-        for (std::size_t led_idx = 0; led_idx < colors.size(); led_idx++ )
-        {
-            RGBColor      color = colors[led_idx];
-            unsigned char red   = RGBGetRValue(color);
-            unsigned char grn   = RGBGetGValue(color);
-            unsigned char blu   = RGBGetBValue(color);
-
-            controller->SetLEDColor(led_idx, red, grn, blu);
-        }
-        controller->SendApply();
-    }
-    else
-    {
-        unsigned char red = RGBGetRValue(colors[0]);
-        unsigned char grn = RGBGetGValue(colors[0]);
-        unsigned char blu = RGBGetBValue(colors[0]);
-
-        controller->SetEffectColor(red, grn, blu);
-    }
-}
-
-void RGBController_KingstonFuryDRAM::UpdateZoneLEDs(int zone)
-{
-    if(controller->GetMode() == FURY_MODE_STATIC)
-    {
-        for (std::size_t led_idx = 0; led_idx < zones[zone].leds_count; led_idx++ )
-        {
-            unsigned int  led   = zones[zone].leds[led_idx].value;
-            RGBColor      color = colors[led];
-            unsigned char red   = RGBGetRValue(color);
-            unsigned char grn   = RGBGetGValue(color);
-            unsigned char blu   = RGBGetBValue(color);
-
-            controller->SetLEDColor(led, red, grn, blu);
-        }
-        controller->SendApply();
-    }
-    else
-    {
-        unsigned char red = RGBGetRValue(colors[0]);
-        unsigned char grn = RGBGetGValue(colors[0]);
-        unsigned char blu = RGBGetBValue(colors[0]);
-
-        controller->SetEffectColor(red, grn, blu);
-    }
-}
-
-void RGBController_KingstonFuryDRAM::UpdateSingleLED(int led)
-{
-    RGBColor      color = colors[led];
-    unsigned char red   = RGBGetRValue(color);
-    unsigned char grn   = RGBGetGValue(color);
-    unsigned char blu   = RGBGetBValue(color);
-
-    if(controller->GetMode() == FURY_MODE_STATIC)
-    {
-        controller->SetLEDColor(led, red, grn, blu);
-    }
-    else
-    {
-        controller->SetEffectColor(red, grn, blu);
-    }
-    controller->SendApply();
-}
-
-void RGBController_KingstonFuryDRAM::DeviceUpdateMode()
-{
-    bool random = (modes[active_mode].color_mode == MODE_COLORS_RANDOM);
-
-    controller->SetMode(modes[active_mode].value, random, modes[active_mode].speed);
-
-    if(modes[active_mode].color_mode == MODE_COLORS_MODE_SPECIFIC)
-    {
-        unsigned char red = RGBGetRValue(modes[active_mode].colors[0]);
-        unsigned char grn = RGBGetGValue(modes[active_mode].colors[0]);
-        unsigned char blu = RGBGetBValue(modes[active_mode].colors[0]);
-
-        controller->SetEffectColor(red, grn, blu);
-    }
-}
-
+/*-----------------------------------------*\
+|  RGBController_KingstonFuryDRAM.cpp       |
+|                                           |
+|  Generic RGB Interface for OpenAuraSDK    |
+|                      Fury RGB interface   |
+|                                           |
+|  Luka Panio (luka177) 11/12/2022          |
+\*-----------------------------------------*/
+
+#include "RGBController_KingstonFuryDRAM.h"
+#include "KingstonFuryDRAMController.h"
+#include "LogManager.h"
+
+/**------------------------------------------------------------------*\
+    @name Kingston Fury DDR5 DRAM
+    @category RAM
+    @type I2C
+    @detectors DetectKingstonFuryDRAMControllers
+    @comment
+\*-------------------------------------------------------------------*/
+
+RGBController_KingstonFuryDRAM::RGBController_KingstonFuryDRAM(KingstonFuryDRAMController* controller_ptr)
+{
+    controller  = controller_ptr;
+
+    name        = "Kingston Fury DDR5 DRAM";
+    vendor      = "Kingston";
+    type        = DEVICE_TYPE_DRAM;
+    description = "Kingston Fury Beast/Renegade DDR5 DRAM Device";
+    location    = controller->GetDeviceLocation();
+
+    mode Static;
+    Static.name       = "Static";
+    Static.value      = FURY_MODE_STATIC;
+    Static.flags      = MODE_FLAG_HAS_PER_LED_COLOR | MODE_FLAG_HAS_BRIGHTNESS;
+    Static.color_mode = MODE_COLORS_PER_LED;
+    Static.brightness_min = 0;
+    Static.brightness_max = 100;
+    Static.brightness = 80;
+    modes.push_back(Static);
+
+
+    mode Rainbow;
+    Rainbow.name       = "Rainbow";
+    Rainbow.value      = FURY_MODE_RAINBOW;
+    Rainbow.flags      = MODE_FLAG_HAS_SPEED |
+        MODE_FLAG_HAS_BRIGHTNESS | MODE_FLAG_HAS_DIRECTION_UD;
+    Rainbow.speed_min  = 0;
+    Rainbow.speed_max  = 60;
+    Rainbow.speed      = 25;
+    Rainbow.brightness_min = 0;
+    Rainbow.brightness_max = 100;
+    Rainbow.brightness = 80;
+    Rainbow.color_mode = MODE_COLORS_NONE;
+    modes.push_back(Rainbow);
+
+    SetupZones();
+}
+
+RGBController_KingstonFuryDRAM::~RGBController_KingstonFuryDRAM()
+{
+    delete controller;
+}
+
+void RGBController_KingstonFuryDRAM::SetupZones()
+{
+    for(unsigned int slot = 0; slot < controller->GetSlotCount(); slot++)
+    {
+        zone* new_zone          = new zone;
+
+        new_zone->name          = "Fury Slot ";
+        new_zone->name.append(std::to_string(slot + 1));
+        new_zone->type          = ZONE_TYPE_LINEAR;
+        new_zone->leds_min      = FURY_LEDS_PER_DIMM;
+        new_zone->leds_max      = FURY_LEDS_PER_DIMM;
+        new_zone->leds_count    = FURY_LEDS_PER_DIMM;
+        new_zone->matrix_map    = NULL;
+
+        zones.push_back(*new_zone);
+    }
+
+    for(std::size_t zone_idx = 0; zone_idx < zones.size(); zone_idx++)
+    {
+        for(std::size_t led_idx = 0; led_idx < zones[zone_idx].leds_count; led_idx++)
+        {
+            led* new_led        = new led();
+
+            new_led->name       = "Fury Slot ";
+            new_led->name.append(std::to_string(zone_idx + 1));
+            new_led->name.append(", LED ");
+            new_led->name.append(std::to_string(led_idx + 1));
+
+            new_led->value      = leds.size();
+
+            leds.push_back(*new_led);
+        }
+    }
+
+    SetupColors();
+}
+
+void RGBController_KingstonFuryDRAM::ResizeZone(int /*zone*/, int /*new_size*/)
+{
+    /*---------------------------------------------------------*\
+    | This device does not support resizing zones               |
+    \*---------------------------------------------------------*/
+}
+
+void RGBController_KingstonFuryDRAM::DeviceUpdateLEDs()
+{
+    controller->SendBegin();
+    controller->SetModeCode(modes[active_mode].value);
+    switch(modes[active_mode].value)
+    {
+    case FURY_MODE_STATIC:
+        for (int slot = 0; slot < controller->GetSlotCount(); slot++)
+        {
+            for (int led_idx = 0; led_idx < zones[slot].leds_count; led_idx++)
+            {
+                RGBColor color = colors[slot * FURY_LEDS_PER_DIMM + led_idx];
+                unsigned char red = RGBGetRValue(color);
+                unsigned char green = RGBGetGValue(color);
+                unsigned char blue = RGBGetBValue(color);
+                controller->SetLEDColor(slot, led_idx, red, green, blue);
+            }
+        }
+        break;
+
+    case FURY_MODE_RAINBOW:
+        // TODO constants
+        controller->SetRegister(FURY_REG_DELAY, 0);
+        break;
+
+    }
+
+    if (modes[active_mode].flags & MODE_FLAG_HAS_DIRECTION_UD)
+    {
+        if (modes[active_mode].direction == MODE_DIRECTION_UP)
+        {
+            controller->SetRegister(FURY_REG_DIRECTION,
+                                    FURY_DIR_BOTTOM_TO_TOP);
+        } else {
+            controller->SetRegister(FURY_REG_DIRECTION,
+                                    FURY_DIR_TOP_TO_BOTTOM);
+        }
+    }
+
+    if (modes[active_mode].flags & MODE_FLAG_HAS_SPEED)
+    {
+        // higher register value represents slower speed
+        controller->SetRegister(FURY_REG_SPEED,
+                                modes[active_mode].speed_max - modes[active_mode].speed);
+    }
+
+    controller->SetRegister(FURY_REG_BRIGHTNESS,
+                            modes[active_mode].brightness);
+    controller->SetNumSlots();
+    controller->SendApply();
+}
+
+void RGBController_KingstonFuryDRAM::UpdateZoneLEDs(int zone)
+{
+    DeviceUpdateLEDs();
+}
+
+void RGBController_KingstonFuryDRAM::UpdateSingleLED(int led)
+{
+    DeviceUpdateLEDs();
+}
+
+void RGBController_KingstonFuryDRAM::DeviceUpdateMode()
+{
+    LOG_DEBUG("[%s] device update mode",
+              FURY_CONTROLLER_NAME);
+    // preamble only necessary when changing modes
+    if (modes[active_mode].value != controller->GetMode())
+    {
+        controller->SendPreamble();
+    }
+    DeviceUpdateLEDs();
+}
-- 
GitLab

