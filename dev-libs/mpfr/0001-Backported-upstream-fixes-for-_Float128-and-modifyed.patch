From 67f1453ad52594dd3e83a670c6e947d369937629 Mon Sep 17 00:00:00 2001
From: "David C. Manuelda" <StormByte@gmail.com>
Date: Fri, 7 Mar 2025 17:40:32 +0100
Subject: [PATCH] Backported upstream fixes for _Float128 and modifyed
 configure to pass checks

Signed-off-by: David C. Manuelda <StormByte@gmail.com>
---
 acinclude.m4          | 11 +++++++----
 configure             |  2 +-
 configure.ac          |  2 +-
 src/get_float128.c    | 17 ++++++++++-------
 src/mpfr.h            |  4 ++--
 src/set_float128.c    | 16 ++++++++++------
 tests/tset_float128.c |  6 +++---
 tests/tversion.c      |  8 +++++++-
 8 files changed, 41 insertions(+), 25 deletions(-)

diff --git a/acinclude.m4 b/acinclude.m4
index d5b5b4b..dfb4f32 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -781,8 +781,11 @@ fi
 # End of decimal float checks
 
 dnl Check if _Float128 or __float128 is available. We also require the
-dnl compiler to support hex constants with the f128 or q suffix (this
-dnl prevents the _Float128 support with GCC's -std=c90, but who cares?).
+dnl compiler to support hex constants with the f128 or q suffix respectively.
+dnl If _Float128 is supported, then the mpfr_float128 macro should be
+dnl defined as this type. We do not define it here because this will be
+dnl done in mpfr.h, and not defining it here is the only way to ensure
+dnl that under "make check", mpfr.h really defines it.
 dnl Note: We use AC_LINK_IFELSE instead of AC_COMPILE_IFELSE since an
 dnl error may occur only at link time, such as under NetBSD:
 dnl   https://mail-index.netbsd.org/pkgsrc-users/2018/02/02/msg026220.html
@@ -809,8 +812,8 @@ return x == 0;
 ]])],
           [AC_MSG_RESULT(yes)
            AC_DEFINE([MPFR_WANT_FLOAT128],2,
-                     [Build float128 functions with float128 fallback])
-           AC_DEFINE([_Float128],[__float128],[__float128 fallback])],
+                     [Build float128 functions with __float128 fallback])
+           AC_DEFINE([mpfr_float128],[__float128],[__float128 fallback])],
           [AC_MSG_RESULT(no)
            if test "$enable_float128" = yes; then
               AC_MSG_ERROR(
diff --git a/configure b/configure
index 2bb3ff8..646587c 100755
--- a/configure
+++ b/configure
@@ -18246,7 +18246,7 @@ printf "%s\n" "yes" >&6; }
 printf "%s\n" "#define MPFR_WANT_FLOAT128 2" >>confdefs.h
 
 
-printf "%s\n" "#define _Float128 __float128" >>confdefs.h
+printf "%s\n" "#define _Float128 mpfr_float128" >>confdefs.h
 
 else $as_nop
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
diff --git a/configure.ac b/configure.ac
index 0da5106..9cb55ef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -277,7 +277,7 @@ AC_ARG_ENABLE(decimal-float,
 
 dnl Warning! Not to be confused with _Decimal128. Thus it is better
 dnl to say binary128 in the description. It can correspond to either
-dnl _Float128 (ISO/IEC TS 18661) or __float128 (old type name).
+dnl _Float128 (ISO C23) or __float128 (old type name).
 AC_ARG_ENABLE(float128,
    [  --disable-float128      explicitly disable binary128 support
   --enable-float128       build conversion functions from/to binary128
diff --git a/src/get_float128.c b/src/get_float128.c
index 5759006..f78ff56 100644
--- a/src/get_float128.c
+++ b/src/get_float128.c
@@ -1,5 +1,5 @@
 /* mpfr_get_float128 -- convert a multiple precision floating-point
-                        number to a _Float128 number
+                        number to a binary128 (a.k.a. float128) number
 
 Copyright 2012-2023 Free Software Foundation, Inc.
 Contributed by the AriC and Caramba projects, INRIA.
@@ -25,17 +25,20 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 
 #ifdef MPFR_WANT_FLOAT128
 
+/* Note: mpfr_get_float128 is a macro defined as the actual binary128 type:
+   either _Float128 or __float128. */
+
 /* generic code */
-_Float128
+mpfr_float128
 mpfr_get_float128 (mpfr_srcptr x, mpfr_rnd_t rnd_mode)
 {
 
   if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (x)))
-    return (_Float128) mpfr_get_d (x, rnd_mode);
+    return (mpfr_float128) mpfr_get_d (x, rnd_mode);
   else /* now x is a normal non-zero number */
     {
-      _Float128 r; /* result */
-      _Float128 m;
+      mpfr_float128 r; /* result */
+      mpfr_float128 m;
       mpfr_exp_t e;  /* exponent of x (before rounding) */
       mpfr_exp_t sh; /* exponent shift, so that x/2^sh is in the double range */
       const int emin = -16381;
@@ -62,7 +65,7 @@ mpfr_get_float128 (mpfr_srcptr x, mpfr_rnd_t rnd_mode)
 
           MPFR_SAVE_EXPO_MARK (expo);
 
-          /* First round x to the target _Float128 precision, taking the
+          /* First round x to the target binary128 precision, taking the
              reduced precision of the subnormals into account, so that all
              subsequent operations are exact (this avoids double rounding
              problems). */
@@ -83,7 +86,7 @@ mpfr_get_float128 (mpfr_srcptr x, mpfr_rnd_t rnd_mode)
                  always work if GMP_NUMB_BITS > IEEE_FLOAT128_MANT_DIG.
                  MPFR_LIMB_HIGHBIT has the advantage to fit on 1 bit. */
               r += yp[i];
-              r *= 1 / (2 * (_Float128) MPFR_LIMB_HIGHBIT);
+              r *= 1 / (2 * (mpfr_float128) MPFR_LIMB_HIGHBIT);
             }
 
           mpfr_clear (y);
diff --git a/src/mpfr.h b/src/mpfr.h
index 6322670..3be8e1c 100644
--- a/src/mpfr.h
+++ b/src/mpfr.h
@@ -476,8 +476,8 @@ __MPFR_DECLSPEC int mpfr_set_decimal128 (mpfr_ptr, _Decimal128, mpfr_rnd_t);
 #endif
 __MPFR_DECLSPEC int mpfr_set_ld (mpfr_ptr, long double, mpfr_rnd_t);
 #ifdef MPFR_WANT_FLOAT128
-__MPFR_DECLSPEC int mpfr_set_float128 (mpfr_ptr, _Float128, mpfr_rnd_t);
-__MPFR_DECLSPEC _Float128 mpfr_get_float128 (mpfr_srcptr, mpfr_rnd_t);
+__MPFR_DECLSPEC int mpfr_set_float128 (mpfr_ptr, mpfr_float128, mpfr_rnd_t);
+__MPFR_DECLSPEC mpfr_float128 mpfr_get_float128 (mpfr_srcptr, mpfr_rnd_t);
 #endif
 __MPFR_DECLSPEC int mpfr_set_z (mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
 __MPFR_DECLSPEC int mpfr_set_z_2exp (mpfr_ptr, mpz_srcptr, mpfr_exp_t,
diff --git a/src/set_float128.c b/src/set_float128.c
index cc3415b..df8fef9 100644
--- a/src/set_float128.c
+++ b/src/set_float128.c
@@ -1,4 +1,4 @@
-/* mpfr_set_float128 -- convert a machine _Float128 number to
+/* mpfr_set_float128 -- convert a binary128 (a.k.a. float128) number to
                         a multiple precision floating-point number
 
 Copyright 2012-2023 Free Software Foundation, Inc.
@@ -27,7 +27,11 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 #ifdef MPFR_WANT_FLOAT128
 
 #if MPFR_WANT_FLOAT128 == 1
-/* _Float128 type from ISO/IEC TS 18661 */
+
+/* Note: mpfr_get_float128 is a macro defined as the actual binary128 type:
+   either _Float128 or __float128. */
+
+/* _Float128 type from ISO C23 */
 # define MPFR_FLOAT128_MAX 0x1.ffffffffffffffffffffffffffffp+16383f128
 #elif MPFR_WANT_FLOAT128 == 2
 /* __float128 type (GNU C extension) */
@@ -37,12 +41,12 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 #endif
 
 int
-mpfr_set_float128 (mpfr_ptr r, _Float128 d, mpfr_rnd_t rnd_mode)
+mpfr_set_float128 (mpfr_ptr r, mpfr_float128 d, mpfr_rnd_t rnd_mode)
 {
   mpfr_t t;
   mp_limb_t *tp;
   int inexact, shift_exp, neg, e, i;
-  _Float128 p[14], q[14];
+  mpfr_float128 p[14], q[14];
   MPFR_SAVE_EXPO_DECL (expo);
 
   /* Check for NaN */
@@ -66,7 +70,7 @@ mpfr_set_float128 (mpfr_ptr r, _Float128 d, mpfr_rnd_t rnd_mode)
       return 0;
     }
   /* Check for ZERO */
-  else if (MPFR_UNLIKELY (d == (_Float128) 0.0))
+  else if (MPFR_UNLIKELY (d == (mpfr_float128) 0.0))
     return mpfr_set_d (r, (double) d, rnd_mode);
 
   shift_exp = 0; /* invariant: remainder to deal with is d*2^shift_exp */
@@ -129,7 +133,7 @@ mpfr_set_float128 (mpfr_ptr r, _Float128 d, mpfr_rnd_t rnd_mode)
 
   for (i = MPFR_LAST_LIMB (t); i >= 0; i--)
     {
-      d *= 2 * (_Float128) MPFR_LIMB_HIGHBIT;
+      d *= 2 * (mpfr_float128) MPFR_LIMB_HIGHBIT;
       tp[i] = (mp_limb_t) d;
       d -= tp[i];
     }
diff --git a/tests/tset_float128.c b/tests/tset_float128.c
index 4f33342..2ec7270 100644
--- a/tests/tset_float128.c
+++ b/tests/tset_float128.c
@@ -33,7 +33,7 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 static void
 check_special (void)
 {
-  _Float128 f;
+  mpfr_float128 f;
   mpfr_t x;
 
   mpfr_init2 (x, 113);
@@ -177,7 +177,7 @@ check_large (void)
   /* check with the largest float128 number 2^16384*(1-2^(-113)) */
   for (f = 1.0, i = 0; i < 113; i++)
     f = f + f;
-  f = f - (_Float128) 1.0;
+  f = f - (mpfr_float128) 1.0;
   mpfr_set_ui (y, 1, MPFR_RNDN);
   mpfr_mul_2ui (y, y, 113, MPFR_RNDN);
   mpfr_sub_ui (y, y, 1, MPFR_RNDN);
@@ -258,7 +258,7 @@ check_small (void)
 {
   int t[5] = { 1, 2, 17, 111, 112 };
   mpfr_exp_t emin;
-  _Float128 e, f;
+  mpfr_float128 e, f;
   int i, j, neg, inex, r;
   mpfr_t w, x, y, z;
 
diff --git a/tests/tversion.c b/tests/tversion.c
index 254236d..a02463f 100644
--- a/tests/tversion.c
+++ b/tests/tversion.c
@@ -309,10 +309,16 @@ main (void)
       err = 1;
     }
 
+#ifdef MPFR_WANT_FLOAT128
+# define MPFR_F128 "yes (" MAKE_STR(mpfr_float128) ")"
+#else
+# define MPFR_F128 "no"
+#endif
+
   (printf) ("[tversion] TLS = %s, float128 = %s, decimal = %s,"
             " GMP internals = %s\n",
             mpfr_buildopt_tls_p () ? "yes" : "no",
-            mpfr_buildopt_float128_p () ? "yes" : "no",
+            MPFR_F128,
             mpfr_buildopt_decimal_p () ? "yes"
 #if defined(DECIMAL_BID_FORMAT)
             " (BID)"
-- 
2.48.1

